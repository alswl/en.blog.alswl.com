<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Type system in Python | Log4D</title>
<meta name="keywords" content="python">
<meta name="description" content="image from pixabay.com
Static typing is becoming more and more popular. Several languages born after 2010, Go, Rust, TypeScript, etc., have gone the static typing route. Some of the previously popular dynamic languages (Python, PHP, JavaScript) are also actively introducing new language features (Type Hint, TypeScript) to enhance static typing.
Having worked on larger projects in Python, I have experienced the difficulties that dynamic languages pose when projects get large: The cost of code regression during the refactoring phase was unusually high, and much of the historical code was afraid to move.">
<meta name="author" content="alswl">
<link rel="canonical" href="https://en.blog.alswl.com/2020/06/type-safe-python/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.1358339a9e54a395efcc4d8a05eb0ab354bd48c92d39ff71d33f2c2a9c66ea2d.css" integrity="sha256-E1gzmp5Uo5XvzE2KBesKs1S9SMktOf9x0z8sKpxm6i0=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://en.blog.alswl.com/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://en.blog.alswl.com/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://en.blog.alswl.com/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://en.blog.alswl.com/apple-touch-icon.png">
<link rel="mask-icon" href="https://en.blog.alswl.com/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-QLEQ62FMM1"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-QLEQ62FMM1', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Type system in Python" />
<meta property="og:description" content="image from pixabay.com
Static typing is becoming more and more popular. Several languages born after 2010, Go, Rust, TypeScript, etc., have gone the static typing route. Some of the previously popular dynamic languages (Python, PHP, JavaScript) are also actively introducing new language features (Type Hint, TypeScript) to enhance static typing.
Having worked on larger projects in Python, I have experienced the difficulties that dynamic languages pose when projects get large: The cost of code regression during the refactoring phase was unusually high, and much of the historical code was afraid to move." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://en.blog.alswl.com/2020/06/type-safe-python/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-06-23T17:54:00+08:00" />
<meta property="article:modified_time" content="2020-06-23T17:54:00+08:00" /><meta property="og:site_name" content="Log4D" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Type system in Python"/>
<meta name="twitter:description" content="image from pixabay.com
Static typing is becoming more and more popular. Several languages born after 2010, Go, Rust, TypeScript, etc., have gone the static typing route. Some of the previously popular dynamic languages (Python, PHP, JavaScript) are also actively introducing new language features (Type Hint, TypeScript) to enhance static typing.
Having worked on larger projects in Python, I have experienced the difficulties that dynamic languages pose when projects get large: The cost of code regression during the refactoring phase was unusually high, and much of the historical code was afraid to move."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://en.blog.alswl.com/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "Type system in Python",
      "item": "https://en.blog.alswl.com/2020/06/type-safe-python/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Type system in Python",
  "name": "Type system in Python",
  "description": "image from pixabay.com\nStatic typing is becoming more and more popular. Several languages born after 2010, Go, Rust, TypeScript, etc., have gone the static typing route. Some of the previously popular dynamic languages (Python, PHP, JavaScript) are also actively introducing new language features (Type Hint, TypeScript) to enhance static typing.\nHaving worked on larger projects in Python, I have experienced the difficulties that dynamic languages pose when projects get large: The cost of code regression during the refactoring phase was unusually high, and much of the historical code was afraid to move.",
  "keywords": [
    "python"
  ],
  "articleBody": " image from pixabay.com\nStatic typing is becoming more and more popular. Several languages born after 2010, Go, Rust, TypeScript, etc., have gone the static typing route. Some of the previously popular dynamic languages (Python, PHP, JavaScript) are also actively introducing new language features (Type Hint, TypeScript) to enhance static typing.\nHaving worked on larger projects in Python, I have experienced the difficulties that dynamic languages pose when projects get large: The cost of code regression during the refactoring phase was unusually high, and much of the historical code was afraid to move. Then the technology stack shifted to Java, and being embraced by the type system made people feel safe.\nIn the last year, I have been working on a stability-oriented operation and maintenance system. Python was used at the beginning of the system selection. I pushed Python 3.7 in the project and used Python’s type system on a large scale to mitigate potential risks.\nGoing back to my roots, I spent some time learning about Python’s design and implementation of the type system. This article is a PEP proposal that describes how far Python has come with the type system.\nType Systems Before we talk about type systems, we need to clarify two concepts, dynamic languages and dynamic types.\nA dynamic programming language is a program that can change its structure at runtime. This structure can include functions, objects, variable types, and program structures. Dynamic types are one type of Type System, i.e., programs that can modify variable types during runtime. The other type is the static type: the variable type is determined at compile time and is not allowed to change at runtime. Another division of the type system is strong and weak types, where strong types are instructions that forbid type mismatches and weak types vice versa.\nThe two concepts, dynamic languages and dynamic types, have different entry points. Python is a dynamic language and a dynamically typed language, or a strongly typed dynamic type. This article will focus on the type system of the Python language and will not cover dynamic language features.\nThe road to type safety There is an ongoing debate within the industry about which is more powerful: dynamic or static types. Proponents of static types see advantages in three areas: performance, error discovery, and efficient refactoring. Static types can significantly improve runtime efficiency by determining the concrete type at compile time; The ability to detect errors at compile time, especially when projects get progressively larger; The type system can help the IDE to prompt for efficient refactoring. Proponents of dynamic typing argue that analyzing code is simpler, less error-prone, and faster to write.\nPython developers have not failed to see this pain point. A series of PEP proposals were created. The type system was introduced to Python through syntax and feature enhancements while retaining the benefits of Python’s dynamic type system.\nPython proposed PEP 484 in 2014, followed by a refined version of PEP 483 (The Theory of Type Hints). Its project implementation, the typing module, was released in 3.5. After several iterations of PEP 484, PEP 526, PEP 544, PEP 586, PEP 589, and PEP 591, Python’s type system has become very rich. It even includes relatively rare features like Structural Subtyping and Literal Typing.\nPEP 483 - Core Concepts Released in December 2014, PEP 483 This is a concise version of the core concepts Guido wrote, making clear the direction, boundaries, do’s and don’ts of building a type system for Python.\nPEP 483 does not talk about concrete engineering implementations, but rather outlines how the Python type system is presented to the public. Define the Type/Class difference, the former being a syntactic analysis concept and the latter a runtime concept. Under this definition, a Class is a Type, but a Type is not necessarily a Class. For example, Union[str, int] is a Type but not a Class.\nPEP 483 also introduces built-in base types: Any / Unison / Optional / Tuple / Callable, which support rich upstream variations.\nThe biggest criticism of the static type system is that it is not flexible enough, and the Go language does not implement generics yet. PEP 483 introduces the use of Python Generic types in a generic The form is as follows:\nS = TypeVar('S', str, bytes) def longest(first: S, second: S) -\u003e S: return first if len(first) \u003e= len(second) else second Finally, PEP 483 also mentions some important minor features:\nAlias Alias Farward Reference (use definition class in definition class method annotations), eg.: solves the problem of needing to reference a Node in a binary tree Node node covariance contravariant Use annotations to mark types Transformation Cast The implementation of PEP 483 relies heavily on PEP 3107 – Function Annotations. This proposal. PEP 3107 introduces the use of function annotations. For example, func(a: a1, b: b1) -\u003e r1This code, thewhere the descriptors after the colon are recorded in the __annotations__ variable of func.\nPEP 3107 shows the effect as follows, where you can clearly see that the function variables are stored:\ndef add(x: int, y: int) -\u003e int: return x + y add.__annotations__ # {'x': int, 'y': int, 'return': int} PS: Python now has Decorator decorators / Annotation annotations, where Annotation is also designed with the same name as Java’s Annotation, a potpourri.\nPEP 484 - Type Hints Core PEP 484 – Type Hints A complete description of how the Python type system is designed, how it is used, and what the details are (typing modules), building on PEP 483\nThis proposal begins by stating:\nPython will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory, even by convention.\nIn one sentence, the proposal eliminates the possibility of Python evolving to a static system at the language level.\nIn addition to the features already explained in PEP 483, the proposal also appeals to me in the following ways:\nAllow adding type descriptions to already existing libraries via Stub Files. Specifically, the typed signature of Python code is described using the .pyi file corresponding to the Python file. This scheme is similar to TS’s @types file. Allowing type overloading with @overload is a long time coming, and Python can actually (in a sense) support overloading. Introduces typing implementation details, such as using abs (Abstract Base Class) to build interfaces for common types, including Sized / Iterable base interfaces. Personally, I think this is actually quite a lot of work, and is a way to sort out the dependencies of existing classes. Python backward (Python 2) compatible methods are introduced, and there are several strategies: Using decorator (@typehints(foo=str, returns=str)), comments, Stub files, Docstring PEP 526 - Variables are also arranged PEP 526 - Syntax for Variable Annotations The core proposal is to add Type Hints support to variables.\nSimilar to function annotation, it is also stored by annotation. The difference is that instead of adding a __annotations__ member to the instance, the annotations information for the variable is stored in the context variable __annotations__. This is actually quite understandable: when a variable type is defined, the variable is not yet initialized.\nI’ll write a demo to demonstrate this:\nfrom typing import List users: List[int] # print(__annotations__) # {'users': typing.List[int]} As you can see, the above demo has the effect of creating a users in the context variable, but this users doesn’t actually exist, it just defines the type. If you run print(users) it will throw NameError: name 'users' is not defined.\nIt is clearer to look at the bytecode:\nL. 1 0 SETUP_ANNOTATIONS L. 1 2 LOAD_CONST 0 4 LOAD_CONST ('List',) 6 IMPORT_NAME typing 8 IMPORT_FROM List 10 STORE_NAME List 12 POP_TOP L. 3 14 LOAD_NAME List 16 LOAD_NAME int 18 BINARY_SUBSCR 20 LOAD_NAME __annotations__ 22 LOAD_STR 'users' 24 STORE_SUBSCR 26 LOAD_CONST None 28 RETURN_VALUE As you can clearly see, instead of creating a variable named users, the __annotations__ variable is used. Note: Python stores variables using the opcode STORE_NAME.\nPS: There are a number of rejected proposals in this proposal, which is quite interesting, and the community has come up with a lot of strange and clever ideas. You can see the caution of the community decision, the difficulty of upgrading the stock system.\nPEP 544 - Nominal Subtyping vs Structural Subtyping The type system discussed in PEP 484 is Nominal Subtyping. This PEP 544 – Protocols: Structural subtyping (static duck typing) This PEP 544 – Protocols: Structural subtyping (static duck typing) is proposed for Structural subtyping.If I had to translate it, I think it could be called named subtypes / isomorphic subtypes. Note that some people also refer to Structural Subtyping as Duck Typing, but the two are not the same, see Duck typing / Comparison with other type systems.\nNominal Subtyping refers to matching types literally, while Structural Subtyping matches by structure (behavior). For example, Go’s Type is a Structural Subtyping implementation.\nHere is a simple demo to demonstrate the latter:\nfrom typing import Iterator, Iterable class Bucket: ... def __len__(self) -\u003e int: ... def __iter__(self) -\u003e Iterator[int]: ... def collect(items: Iterable[int]) -\u003e int: ... result: int = collect(Bucket()) # Passes type check The code defines the type Bucket and provides two class members. These two class members happen to be the definition of Interator.Then in practice, you can use Bucket instead of Iterable.\nPEP 586 / PEP 589 / PEP 591 Continuous enhancement PEP 586 – Literal Types The Python 3.8 implementation supports the use of literals as types. For example Literal[4], and for a more semantic example Literal['GREEN'].\nMy first thought was that this is very similar to Symbol in Scala, which is written as Symbol(\"GREEN\"). This feature is quite collegial and easy to write in the DSL.Scala officials have said that the Symbol feature may be removed in the future, so it is recommended to use constants instead.\nPEP 589 – TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys Add a Type of key to Dict, inheriting from TypedDict.\nPEP 591 – Adding a final qualifier to typing Add the concepts of final / Final, the former is a decorator, the latter is an annotation that marks the class/function/variable as unmodifiable.\nAt this point, Python 3.8 has the type system features we need every day (not at runtime 😂).\nSummary Unfortunately, the typing module is clearly marked in the documentation as:\nThe Python runtime does not enforce function and variable type annotations. They can be used by third party tools such as type checkers, IDEs, linters, etc.\nNamely, the Python runtime (Intercepter / Code Evaluator) does not support type decorators for functions and variables. These decorators can only be checked by third-party tools, such as type checkers, IDEs, statics, and Linter.\nThis information illustrates the limitations of Python’s attempts at type safety. All the restrictions, constraints, and limitations don’t happen at runtime. The only way to harvest engineering-above-board value from the type system is to use third-party tools.\nIt’s true that the Python community is trying to move closer to a type system, but how far can this non-language level Runtime support go? Python lacks a golden father, and its godfather Red Hat has limited resources to invest. Even the community hasn’t finished switching from Python 2 to Python 3 yet, so why? The input/output ratio is too low, the new features are not attractive enough, and there are too many alternatives.\nOn the other hand, look at the competition: Dynamic languages are moving closer to static languages, and static languages are absorbing features from dynamic languages. For example, the REPL (Read-Eval-Print-Loop) in Java 14. Kotlin / Scala and other languages Type Inference. Perhaps this evolution is more acceptable to users.\n参考 typing — Support for type hints — Python 3.8.3 documentation PEP 483 – The Theory of Type Hints | Python.org PEP 484 – Type Hints | Python.org the state of type hints in Python ",
  "wordCount" : "1979",
  "inLanguage": "en",
  "datePublished": "2020-06-23T17:54:00+08:00",
  "dateModified": "2020-06-23T17:54:00+08:00",
  "author":{
    "@type": "Person",
    "name": "alswl"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://en.blog.alswl.com/2020/06/type-safe-python/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Log4D",
    "logo": {
      "@type": "ImageObject",
      "url": "https://en.blog.alswl.com/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://en.blog.alswl.com" accesskey="h" title="Log4D (Alt + H)">Log4D</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="http://blog.alswl.com/" title="中文博客">
                    <span>中文博客</span>&nbsp;
                    <svg fill="none" shape-rendering="geometricPrecision" stroke="currentColor" stroke-linecap="round"
                        stroke-linejoin="round" stroke-width="2.5" viewBox="0 0 24 24" height="12" width="12">
                        <path d="M18 13v6a2 2 0 01-2 2H5a2 2 0 01-2-2V8a2 2 0 012-2h6"></path>
                        <path d="M15 3h6v6"></path>
                        <path d="M10 14L21 3"></path>
                    </svg>
                </a>
            </li>
            <li>
                <a href="https://en.blog.alswl.com/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://en.blog.alswl.com/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://en.blog.alswl.com/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://en.blog.alswl.com/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://en.blog.alswl.com">Home</a>&nbsp;»&nbsp;<a href="https://en.blog.alswl.com/posts/">Posts</a></div>
    <h1 class="post-title">
      Type system in Python
    </h1>
    <div class="post-meta"><span title='2020-06-23 17:54:00 +0800 +0800'>2020-06-23</span>&nbsp;·&nbsp;alswl

</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><nav id="TableOfContents">
  <ul>
    <li><a href="#type-systems">Type Systems</a></li>
    <li><a href="#the-road-to-type-safety">The road to type safety</a>
      <ul>
        <li><a href="#pep-483---core-concepts">PEP 483 - Core Concepts</a></li>
        <li><a href="#pep-484---type-hints-core">PEP 484 - Type Hints Core</a></li>
        <li><a href="#pep-526---variables-are-also-arranged">PEP 526 - Variables are also arranged</a></li>
        <li><a href="#pep-544---nominal-subtyping-vs-structural-subtyping">PEP 544 - Nominal Subtyping vs Structural Subtyping</a></li>
        <li><a href="#pep-586--pep-589--pep-591-continuous-enhancement">PEP 586 / PEP 589 / PEP 591 Continuous enhancement</a></li>
      </ul>
    </li>
    <li><a href="#summary">Summary</a></li>
    <li><a href="#参考">参考</a></li>
  </ul>
</nav>
        </div>
    </details>
</div>

  <div class="post-content"><p>




<img loading="lazy" src="/images/upload_dropbox/202006/wall.png" alt="wall"  />



<small>image from pixabay.com</small></p>
<p>Static typing is becoming more and more popular.
Several languages born after 2010, Go, Rust, TypeScript, etc., have gone the static typing route.
Some of the previously popular dynamic languages (Python, PHP, JavaScript) are also actively introducing new language features (Type Hint, TypeScript) to enhance static typing.</p>
<p>Having worked on larger projects in Python, I have experienced the difficulties that dynamic languages pose when projects get large:
The cost of code regression during the refactoring phase was unusually high, and much of the historical code was afraid to move.
Then the technology stack shifted to Java, and being embraced by the type system made people feel safe.</p>
<p>In the last year, I have been working on a stability-oriented operation and maintenance system. Python was used at the beginning of the system selection.
I pushed Python 3.7 in the project and used Python&rsquo;s type system on a large scale to mitigate potential risks.</p>
<p>Going back to my roots, I spent some time learning about Python&rsquo;s design and implementation of the type system.
This article is a PEP proposal that describes how far Python has come with the type system.</p>
<!-- more -->
<h2 id="type-systems">Type Systems<a hidden class="anchor" aria-hidden="true" href="#type-systems">#</a></h2>
<p>Before we talk about type systems, we need to clarify two concepts, dynamic languages and dynamic types.</p>
<p>A dynamic programming language is a program that can change its structure at runtime.
This structure can include functions, objects, variable types, and program structures.
Dynamic types are one type of Type System, i.e., programs that can modify variable types during runtime.
The other type is the static type: the variable type is determined at compile time and is not allowed to change at runtime.
Another division of the type system is strong and weak types, where strong types are instructions that forbid type mismatches and weak types vice versa.</p>
<p>The two concepts, dynamic languages and dynamic types, have different entry points.
Python is a dynamic language and a dynamically typed language, or a strongly typed dynamic type.
This article will focus on the type system of the Python language and will not cover dynamic language features.</p>
<h2 id="the-road-to-type-safety">The road to type safety<a hidden class="anchor" aria-hidden="true" href="#the-road-to-type-safety">#</a></h2>
<p>There is an ongoing debate within the industry about which is more powerful: dynamic or static types.
Proponents of static types see advantages in three areas: performance, error discovery, and efficient refactoring.
Static types can significantly improve runtime efficiency by determining the concrete type at compile time;
The ability to detect errors at compile time, especially when projects get progressively larger;
The type system can help the IDE to prompt for efficient refactoring.
Proponents of dynamic typing argue that analyzing code is simpler, less error-prone, and faster to write.</p>
<p>Python developers have not failed to see this pain point.
A series of PEP proposals were created.
The type system was introduced to Python through syntax and feature enhancements while retaining the benefits of Python&rsquo;s dynamic type system.</p>
<p>Python proposed PEP 484 in 2014, followed by a refined version of PEP 483 (The Theory of Type Hints).
Its project implementation, the <a href="https://docs.python.org/3/library/typing.html">typing</a> module, was released in 3.5.
After several iterations of PEP 484, PEP 526, PEP 544, PEP 586, PEP 589, and PEP 591, Python&rsquo;s type system has become very rich.
It even includes relatively rare features like Structural Subtyping and Literal Typing.</p>
<h3 id="pep-483---core-concepts">PEP 483 - Core Concepts<a hidden class="anchor" aria-hidden="true" href="#pep-483---core-concepts">#</a></h3>
<p>Released in December 2014, <a href="https://www.python.org/dev/peps/pep-0483/">PEP 483</a>
This is a concise version of the core concepts Guido wrote, making clear the direction, boundaries, do&rsquo;s and don&rsquo;ts of building a type system for Python.</p>
<p>PEP 483 does not talk about concrete engineering implementations, but rather outlines how the Python type system is presented to the public.
Define the Type/Class difference, the former being a syntactic analysis concept and the latter a runtime concept.
Under this definition, a Class is a Type, but a Type is not necessarily a Class.
For example, <code>Union[str, int]</code> is a Type but not a Class.</p>
<p>PEP 483 also introduces built-in base types: <code>Any</code> / <code>Unison</code> / <code>Optional</code> / <code>Tuple</code> / <code>Callable</code>, which support rich upstream variations.</p>
<p>The biggest criticism of the static type system is that it is not flexible enough, and the Go language does not implement generics yet.
PEP 483 introduces the use of Python Generic types in a generic
The form is as follows:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="n">S</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s1">&#39;S&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">longest</span><span class="p">(</span><span class="n">first</span><span class="p">:</span> <span class="n">S</span><span class="p">,</span> <span class="n">second</span><span class="p">:</span> <span class="n">S</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">S</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">first</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">first</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="nb">len</span><span class="p">(</span><span class="n">second</span><span class="p">)</span> <span class="k">else</span> <span class="n">second</span>
</span></span></code></pre></div><p>Finally, PEP 483 also mentions some important minor features:</p>
<ul>
<li>Alias Alias</li>
<li>Farward Reference (use definition class in definition class method annotations), eg.: solves the problem of needing to reference a Node in a binary tree Node node</li>
<li>covariance contravariant</li>
<li>Use annotations to mark types</li>
<li>Transformation Cast</li>
</ul>
<p>The implementation of PEP 483 relies heavily on <a href="https://www.python.org/dev/peps/pep-3107/">PEP 3107 &ndash; Function Annotations</a>.
This proposal. PEP 3107 introduces the use of function annotations. For example, <code>func(a: a1, b: b1) -&gt; r1</code>This code, thewhere the descriptors after the colon are recorded in the <code>__annotations__</code> variable of func.</p>
<p>PEP 3107 shows the effect as follows, where you can clearly see that the function variables are stored:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">add</span><span class="p">(</span><span class="n">x</span><span class="p">:</span> <span class="nb">int</span><span class="p">,</span> <span class="n">y</span><span class="p">:</span> <span class="nb">int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="k">return</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">add</span><span class="o">.</span><span class="vm">__annotations__</span>
</span></span><span class="line"><span class="cl"><span class="c1"># {&#39;x&#39;: int, &#39;y&#39;: int, &#39;return&#39;: int}</span>
</span></span></code></pre></div><p>PS: Python now has Decorator decorators / Annotation annotations, where Annotation is also designed with the same name as Java&rsquo;s Annotation, a potpourri.</p>
<h3 id="pep-484---type-hints-core">PEP 484 - Type Hints Core<a hidden class="anchor" aria-hidden="true" href="#pep-484---type-hints-core">#</a></h3>
<p><a href="https://www.python.org/dev/peps/pep-0484/">PEP 484 &ndash; Type Hints</a>
A complete description of how the Python type system is designed, how it is used, and what the details are (typing modules), building on PEP 483</p>
<p>This proposal begins by stating:</p>
<blockquote>
<p>Python will remain a dynamically typed language, and the authors have no desire to ever make type hints mandatory,
even by convention.</p>
</blockquote>
<p>In one sentence, the proposal eliminates the possibility of Python evolving to a static system at the language level.</p>
<p>In addition to the features already explained in PEP 483, the proposal also appeals to me in the following ways:</p>
<ul>
<li>Allow adding type descriptions to already existing libraries via Stub Files. Specifically, the typed signature of Python code is described using the <code>.pyi</code> file corresponding to the Python file.
This scheme is similar to TS&rsquo;s <code>@types</code> file.</li>
<li>Allowing type overloading with <code>@overload</code> is a long time coming, and Python can actually (in a sense) support overloading.</li>
<li>Introduces typing implementation details, such as using abs (Abstract Base Class) to build interfaces for common types, including <code>Sized</code> / <code>Iterable</code> base interfaces.
Personally, I think this is actually quite a lot of work, and is a way to sort out the dependencies of existing classes.</li>
<li>Python backward (Python 2) compatible methods are introduced, and there are several strategies:
Using decorator (<code>@typehints(foo=str, returns=str)</code>), comments, Stub files, Docstring</li>
</ul>
<h3 id="pep-526---variables-are-also-arranged">PEP 526 - Variables are also arranged<a hidden class="anchor" aria-hidden="true" href="#pep-526---variables-are-also-arranged">#</a></h3>
<p><a href="https://www.python.org/dev/peps/pep-0526/">PEP 526 - Syntax for Variable Annotations</a>
The core proposal is to add Type Hints support to variables.</p>
<p>Similar to <code>function annotation</code>, it is also stored by annotation.
The difference is that instead of adding a <code>__annotations__</code> member to the instance, the annotations information for the variable is stored in the context variable <code>__annotations__</code>.
This is actually quite understandable: when a variable type is defined, the variable is not yet initialized.</p>
<p>I&rsquo;ll write a demo to demonstrate this:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">List</span>
</span></span><span class="line"><span class="cl"><span class="n">users</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="c1"># print(__annotations__)</span>
</span></span><span class="line"><span class="cl"><span class="c1"># {&#39;users&#39;: typing.List[int]}</span>
</span></span></code></pre></div><p>As you can see, the above demo has the effect of creating a <code>users</code> in the context variable, but this <code>users</code> doesn&rsquo;t actually exist, it just defines the type.
If you run <code>print(users)</code> it will throw <code>NameError: name 'users' is not defined</code>.</p>
<p>It is clearer to look at the bytecode:</p>
<pre tabindex="0"><code> L.   1         0  SETUP_ANNOTATIONS

 L.   1         2  LOAD_CONST               0
                4  LOAD_CONST               (&#39;List&#39;,)
                6  IMPORT_NAME              typing
                8  IMPORT_FROM              List
               10  STORE_NAME               List
               12  POP_TOP

 L.   3        14  LOAD_NAME                List
               16  LOAD_NAME                int
               18  BINARY_SUBSCR
               20  LOAD_NAME                __annotations__
               22  LOAD_STR                 &#39;users&#39;
               24  STORE_SUBSCR
               26  LOAD_CONST               None
               28  RETURN_VALUE
</code></pre><p>As you can clearly see, instead of creating a variable named users, the <code>__annotations__</code> variable is used.
Note: Python stores variables using the opcode <code>STORE_NAME</code>.</p>
<p>PS: There are a number of rejected proposals in this proposal, which is quite interesting, and the community has come up with a lot of strange and clever ideas.
You can see the caution of the community decision, the difficulty of upgrading the stock system.</p>
<h3 id="pep-544---nominal-subtyping-vs-structural-subtyping">PEP 544 - Nominal Subtyping vs Structural Subtyping<a hidden class="anchor" aria-hidden="true" href="#pep-544---nominal-subtyping-vs-structural-subtyping">#</a></h3>
<p>The type system discussed in PEP 484 is Nominal Subtyping.
This <a href="https://www.python.org/dev/peps/pep-0544/">PEP 544 &ndash; Protocols: Structural subtyping (static duck typing)</a>
This <a href="">PEP 544 &ndash; Protocols: Structural subtyping (static duck typing)</a> is proposed for Structural subtyping.If I had to translate it, I think it could be called named subtypes / isomorphic subtypes.
Note that some people also refer to Structural Subtyping as Duck Typing, but the two are not the same, see
<a href="https://en.wikipedia.org/wiki/Duck_typing#Structural_type_systems">Duck typing / Comparison with other type systems</a>.</p>
<p>Nominal Subtyping refers to matching types literally, while Structural Subtyping matches by structure (behavior).
For example, Go&rsquo;s Type is a Structural Subtyping implementation.</p>
<p>Here is a simple demo to demonstrate the latter:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Iterator</span><span class="p">,</span> <span class="n">Iterable</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">class</span> <span class="nc">Bucket</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="nb">int</span><span class="p">]:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">collect</span><span class="p">(</span><span class="n">items</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="nb">int</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span> <span class="o">...</span>
</span></span><span class="line"><span class="cl"><span class="n">result</span><span class="p">:</span> <span class="nb">int</span> <span class="o">=</span> <span class="n">collect</span><span class="p">(</span><span class="n">Bucket</span><span class="p">())</span>  <span class="c1"># Passes type check</span>
</span></span></code></pre></div><p>The code defines the type Bucket and provides two class members. These two class members happen to be the definition of Interator.Then in practice, you can use Bucket instead of Iterable.</p>
<h3 id="pep-586--pep-589--pep-591-continuous-enhancement">PEP 586 / PEP 589 / PEP 591 Continuous enhancement<a hidden class="anchor" aria-hidden="true" href="#pep-586--pep-589--pep-591-continuous-enhancement">#</a></h3>
<p><a href="https://www.python.org/dev/peps/pep-0586/">PEP 586 &ndash; Literal Types</a>
The Python 3.8 implementation supports the use of literals as types.
For example <code>Literal[4]</code>, and for a more semantic example <code>Literal['GREEN']</code>.</p>
<p>My first thought was that this is very similar to Symbol in Scala, which is written as <code>Symbol(&quot;GREEN&quot;)</code>.
This feature is quite collegial and easy to write in the DSL.Scala officials have said that the Symbol feature may be removed in the future, so it is recommended to use constants instead.</p>
<p><a href="https://www.python.org/dev/peps/pep-0589/">PEP 589 &ndash; TypedDict: Type Hints for Dictionaries with a Fixed Set of Keys</a>
Add a Type of key to Dict, inheriting from <code>TypedDict</code>.</p>
<p><a href="https://www.python.org/dev/peps/pep-0591/">PEP 591 &ndash; Adding a final qualifier to typing</a>
Add the concepts of <code>final</code> / <code>Final</code>, the former is a decorator, the latter is an annotation that marks the class/function/variable as unmodifiable.</p>
<p>At this point, Python 3.8 has the type system features we need every day (not at runtime 😂).</p>
<h2 id="summary">Summary<a hidden class="anchor" aria-hidden="true" href="#summary">#</a></h2>
<p>Unfortunately, the <code>typing</code> module is clearly marked in the documentation as:</p>
<blockquote>
<p>The Python runtime does not enforce function and variable type annotations. They can be used by third party tools
such as type checkers, IDEs, linters, etc.</p>
</blockquote>
<p>Namely, the Python runtime (Intercepter / Code Evaluator) does not support type decorators for functions and variables.
These decorators can only be checked by third-party tools, such as type checkers, IDEs, statics, and Linter.</p>
<p>This information illustrates the limitations of Python&rsquo;s attempts at type safety. All the restrictions, constraints, and limitations don&rsquo;t happen at runtime.
The only way to harvest engineering-above-board value from the type system is to use third-party tools.</p>
<p>It&rsquo;s true that the Python community is trying to move closer to a type system, but how far can this non-language level Runtime support go?
Python lacks a golden father, and its godfather Red Hat has limited resources to invest. Even the community hasn&rsquo;t finished switching from Python 2 to Python 3 yet, so why?
The input/output ratio is too low, the new features are not attractive enough, and there are too many alternatives.</p>
<p>On the other hand, look at the competition:
Dynamic languages are moving closer to static languages, and static languages are absorbing features from dynamic languages. For example, the REPL (Read-Eval-Print-Loop) in Java 14.
Kotlin / Scala and other languages Type Inference.
Perhaps this evolution is more acceptable to users.</p>
<h2 id="参考">参考<a hidden class="anchor" aria-hidden="true" href="#参考">#</a></h2>
<ul>
<li><a href="https://docs.python.org/3/library/typing.html">typing — Support for type hints — Python 3.8.3 documentation</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0483/#type-variables">PEP 483 &ndash; The Theory of Type Hints | Python.org</a></li>
<li><a href="https://www.python.org/dev/peps/pep-0484/#abstract">PEP 484 &ndash; Type Hints | Python.org</a></li>
<li><a href="https://www.bernat.tech/the-state-of-type-hints-in-python/">the state of type hints in Python</a></li>
</ul>

<hr />
<p>原文链接: <a href="https://en.blog.alswl.com/2020/06/type-safe-python/">Type system in Python | Log4D</a></p>
<p>3a1ff193cee606bd1e2ea554a16353ee</p>
<p>欢迎关注我的微信公众号：<a
href="http://mp.weixin.qq.com/mp/getmasssendmsg?__biz=MzIyNTIwMTU3MQ==#wechat_webview_type=1&amp;wechat_redirect">窥豹</a></p>
<figure>
<img
src="https://d05fae.dijingchao.com/upload_dropbox/201605/qrcode_for_gh_17e2f9c2caa4_258.jpg"
alt="窥豹" />
<figcaption aria-hidden="true">窥豹</figcaption>
</figure>

    
  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://en.blog.alswl.com/tags/python/">python</a></li>
    </ul>
<nav class="paginav">
  <a class="prev" href="https://en.blog.alswl.com/2022/10/self-hosted-excalidraw/">
    <span class="title">« Prev</span>
    <br>
    <span>Self hosted online collaborative drawing platform Excalidraw</span>
  </a>
</nav>

  </footer><script src="https://utteranc.es/client.js"
        repo="alswl/en.blog.alswl.com"
        issue-term="pathname"
        theme="preferred-color-scheme"
        crossorigin="anonymous"
        async>
</script>

</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://en.blog.alswl.com">Log4D</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerHTML = 'copy';

        function copyingDone() {
            copybutton.innerHTML = 'copied!';
            setTimeout(() => {
                copybutton.innerHTML = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
