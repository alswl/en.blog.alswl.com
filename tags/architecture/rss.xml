<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Architecture on Log4D</title>
    <link>https://en.blog.alswl.com/tags/architecture/</link>
    <description>Recent content in Architecture on Log4D</description>
    <generator>Hugo -- 0.148.2</generator>
    <language>en-us</language>
    <lastBuildDate>Sat, 23 Sep 2023 18:22:27 +0800</lastBuildDate>
    <atom:link href="https://en.blog.alswl.com/tags/architecture/rss.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>GitOps and Version Management</title>
      <link>https://en.blog.alswl.com/2023/09/gitops-and-version-management/</link>
      <pubDate>Sat, 23 Sep 2023 18:22:27 +0800</pubDate>
      <guid>https://en.blog.alswl.com/2023/09/gitops-and-version-management/</guid>
      <description>&lt;p&gt;




&lt;img loading=&#34;lazy&#34; src=&#34;https://en.blog.alswl.com/images/202309/car.png&#34; alt=&#34;car&#34;  /&gt;


&lt;/p&gt;
&lt;p&gt;&lt;small&gt;image via &lt;a href=&#34;https://www.shipvehicles.com/step-by-step-guide-for-state-to-state-transport/&#34;&gt;shipvehicles&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;p&gt;Using GitOps to manage delivery content is a common DevOps practice. We use Git for version control and Git tags to track the versions of deployed software. While this may seem to work, the concept of versioning is far from that simple in the age of cloud-native technology.&lt;/p&gt;
&lt;h2 id=&#34;the-version-problem&#34;&gt;The Version Problem&lt;/h2&gt;
&lt;p&gt;After introducing GitOps into the DevOps workflow, we can leverage GitOps for continuous integration and continuous delivery. GitOps addresses three core concerns: &lt;strong&gt;content&lt;/strong&gt;, &lt;strong&gt;version&lt;/strong&gt;, and &lt;strong&gt;collaboration&lt;/strong&gt;. Yet we often focus on content and overlook version management.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202309/car.png" alt="car"  />


</p>
<p><small>image via <a href="https://www.shipvehicles.com/step-by-step-guide-for-state-to-state-transport/">shipvehicles</a></small></p>
<p>Using GitOps to manage delivery content is a common DevOps practice. We use Git for version control and Git tags to track the versions of deployed software. While this may seem to work, the concept of versioning is far from that simple in the age of cloud-native technology.</p>
<h2 id="the-version-problem">The Version Problem</h2>
<p>After introducing GitOps into the DevOps workflow, we can leverage GitOps for continuous integration and continuous delivery. GitOps addresses three core concerns: <strong>content</strong>, <strong>version</strong>, and <strong>collaboration</strong>. Yet we often focus on content and overlook version management.</p>
<p>What version-management issues need to be solved in a GitOps process?</p>
<p>A complete GitOps solution includes content description (Manifest), build strategy (Builder), and application strategy (Applier). Content description has given rise to many description languages, from traditional <a href="https://www.ansible.com/">Ansible</a> / <a href="https://www.chef.io/products/chef-infra">Chef</a> to cloud and cloud-native favourites like <a href="https://www.terraform.io/">Terraform</a>, <a href="https://helm.sh/">Helm</a>, and <a href="https://kustomize.io/">Kustomize</a>. With so many ways to describe content, pinning down an application‚Äôs version becomes very complex.</p>
<p>When we talk about version, do we <mark>mean the version of the application source code, the version of an image, or the version of an infrastructure-as-code (IaC) repository</mark>? Furthermore, when releasing a set of related applications‚Äîe.g. frontend and backend, or a system made of multiple backend apps‚Äîhow do we clearly describe the <mark>version dependencies</mark> between them?</p>
<p>Inaccurate versioning leads to problems such as wrong release versions, tangled application dependencies, and inability to roll back.</p>
<p>Many teams handle this vaguely: ship the latest version, deploy backend before frontend. In a complex product team or one that must maintain multiple stable versions, this rough approach is not acceptable.</p>
<p>Version management addresses not only <mark>version identification</mark> but also <mark>dependencies</mark> between applications. GitOps version management therefore needs to answer:</p>
<ul>
<li>How to build artifacts delivered to customers, how to define their versions, and how to present all versions.</li>
<li>How to resolve version dependencies when a set of software has them.</li>
<li>How to describe a system when a set of software forms one.</li>
</ul>
<p>Version management is important for any delivered product. We will break down this topic step by step and move from the original questions to GitOps version-management best practices.</p>
<h2 id="a-brief-introduction-to-gitops">A Brief Introduction to GitOps</h2>
<p>Before going further, here is a short overview of GitOps so we share the same understanding of key concepts.</p>
<p>The core idea of GitOps is <mark>infrastructure as code (IaC)</mark>: using declarative descriptions instead of imperative ones. IaC content is usually based on some paradigm that describes the desired state of a target. That paradigm can be Terraform, Kubernetes YAML, <a href="https://www.pulumi.com/">Pulumi</a>, or even Ansible. The target can be cloud services, Kubernetes, or physical machines. In short, by using YAML instead of Bash scripts, we can greatly improve the accuracy and controllability of changes.</p>
<p>For GitOps, whether you use Git is not the main point; you could use SVN. Git is simply more widely used and fits well with team collaboration and CI/CD. With a Git repository, you also get versioning based on Git revision / tag / branch, which in practice means version history and managing multiple versions in parallel.</p>
<p>Describing things only by Git revision is still not enough for real-world needs.</p>
<h2 id="the-root-of-the-problem--versions-of-binaries-and-startup-config">The Root of the Problem ‚Äî Versions of Binaries and Startup Config</h2>
<p>When we trace versions to their source, the most primitive version is the version of the code.</p>
<p>What is the version of the code? Is it the version in the code repository or the version of the application built from that code? This version is not the version in the version-control system (e.g. Git / Mercurial / SVN). Although the two are often related, the code itself is just a set of files; once a build succeeds, there is a version. If it is not defined, the version is unknown and not tied to the repository.</p>
<blockquote>
<p>Note: From here on we do not distinguish between Git / Mercurial / SVN; we use Git as the stand-in for all of them.</p></blockquote>
<p>Also note that in Chinese there are two concepts (Â∫ì Library and ‰ªìÂ∫ì Repository). In neither case does it imply that a ‚Äúlibrary‚Äù must be a versioned (Git/SVN) repository‚Äîwe are not assuming code is always under version control. When we pack source files into a zip (e.g. GitHub‚Äôs zip download), that zip is still a codebase even if it has lost all Git history.</p>
<p>The version of the code is effectively the <mark>version of the application</mark>, as intended by the author. It is usually in the form <code>vx.y.z</code> rather than a Git commit hash, and the most common approach is <a href="https://semver.org/">semantic versioning</a>.</p>
<p>I recommend storing the version in a <code>VERSION</code> file in the code tree. For example, Git‚Äôs <a href="https://github.com/git/git/blob/master/GIT-VERSION-GEN">Version</a> file clearly shows the current version:</p>
<pre tabindex="0"><code>GVF=GIT-VERSION-FILE
DEF_VER=v2.42.GIT
</code></pre><p>The <code>.GIT</code> suffix indicates the code is in development mode. If we switch to a release, e.g. <a href="https://github.com/git/git/blob/v2.39.3/GIT-VERSION-GEN">v2.39.3</a>, we see <code>DEF_VER=v2.39.3</code>, a standard artifact version. Two best practices here:</p>
<ul>
<li>Use a file to store the source version.</li>
<li>The version file in source is always in <code>dev</code> mode; it becomes an official version only after a release tag.</li>
</ul>
<p>The output of the source is not only binaries, executables, and dynamic libraries (<code>.dll</code> / <code>.so</code> / <code>.dylib</code>) but also the corresponding startup configuration files. These configs are usually managed together with the version‚Äîe.g. Nginx‚Äôs <code>nginx.conf</code> and Redis‚Äôs <code>redis.conf</code> should be under version control.</p>
<p>What is built from the source repository is the <strong>artifact</strong>. Artifacts already have two versions:</p>
<ul>
<li>Source version, i.e. the version defined in the <code>VERSION</code> file.</li>
<li>Source repository version, i.e. Git revision.</li>
</ul>
<h2 id="artifact-version-management">Artifact Version Management</h2>
<p>With artifact version management, things get more complex because artifacts introduce more questions:</p>
<ul>
<li>What is an artifact and what does it consist of? (Answered above.)</li>
<li>How is an artifact installed? What is the installer and what is the runtime?</li>
<li>How is artifact information managed centrally? How is data managed?</li>
<li>Do artifacts depend on each other? How are dependencies and version constraints handled?</li>
</ul>
<p>The concept of artifact is central. One key idea: <mark>artifacts can be turned into new artifacts by packers</mark>.</p>
<p>Because artifacts have versions and new artifacts get new versions, we end up with multiple layers. To avoid losing the original version, we extend the notion of version to <mark>Upstream Version</mark>‚Äîthe version assigned by the software author, the source of all versions.</p>
<p>Why can one artifact become another? Consider containers in Kubernetes. A container is a delivery format: it puts the executable and startup config into an image that can run in a container environment. The image in a registry is itself an artifact.</p>
<p>Helm / Kustomize are also delivery formats (packaging toolchains). Each layer solves a specific problem and can run in a given environment (e.g. container, Kubernetes, cloud infrastructure).</p>
<p>Every artifact is built and has its own <mark>packaging info</mark>, which can change and thus add another version. In practice we want the artifact‚Äôs version tied to its upstream version. Each packaging mechanism may have its own config but should still follow the upstream version. For example, a Kubernetes Workload references an image; the Workload description is extra info, while the image remains under upstream control.</p>
<p><mark>Artifact + Packaging Info = New Artifact</mark>. Artifacts are packed into new artifacts until the final installer deploys them into the target environment.</p>
<p>When these artifacts can be described in files (IaC), we get various IaC repositories, which are the core objects of GitOps.</p>
<h2 id="concepts-at-a-glance">Concepts at a Glance</h2>
<p>Here is a concise map of these concepts:</p>
<table>
  <thead>
      <tr>
          <th>Chinese</th>
          <th>English</th>
          <th>Explanation</th>
      </tr>
  </thead>
  <tbody>
      <tr>
          <td>Ê∫ê‰ª£Á†Å</td>
          <td>Source Code</td>
          <td>The set of source files for a program or application</td>
      </tr>
      <tr>
          <td>‰ª£Á†Å‰ªìÂ∫ì</td>
          <td>Source Code Repo</td>
          <td>The unit of version control that holds the source code</td>
      </tr>
      <tr>
          <td>ÁâàÊú¨</td>
          <td>Version</td>
          <td>Application version corresponding to the source; human-defined, semantic; sometimes called Upstream Version</td>
      </tr>
      <tr>
          <td>ÂèØÊâßË°åÊñá‰ª∂</td>
          <td>Executable File</td>
          <td>Build output, usually an ELF executable or a library</td>
      </tr>
      <tr>
          <td>ÂêØÂä®ÈÖçÁΩÆÊñá‰ª∂</td>
          <td>Configuration File</td>
          <td>Startup config for the ELF/Lib, distinct from general config (e.g. Kubernetes YAML)</td>
      </tr>
      <tr>
          <td>Âà∂ÂìÅ</td>
          <td>Artifact</td>
          <td>A set of executable + startup config that can run in a runtime; usually file-based; artifacts can nest other artifacts</td>
      </tr>
      <tr>
          <td>ÂÆâË£ÖÂô®</td>
          <td>Installer</td>
          <td>Tool that installs the artifact into the runtime</td>
      </tr>
      <tr>
          <td>ËøêË°åÊó∂</td>
          <td>Runtime</td>
          <td>Environment where the artifact runs, e.g. an OS, Kubernetes, Docker Engine</td>
      </tr>
      <tr>
          <td>ÊâìÂåÖÂô®</td>
          <td>Packer</td>
          <td>Tool that packs artifacts into a given format (new artifact)</td>
      </tr>
      <tr>
          <td>ÊâìÂåÖÈôÑÂ±û‰ø°ÊÅØ</td>
          <td>Packaging Info</td>
          <td>Extra info needed when packing, e.g. container OS, process resources, default env vars</td>
      </tr>
  </tbody>
</table>
<p>Together these concepts form the core of artifact version management and help us manage and trace versions and their relationships.</p>
<h3 id="packer">Packer</h3>
<p>A packer is a tool that turns artifacts into a specific format via packaging (compile, link, merge, archive, etc.), producing a new artifact. Its input is usually upstream‚Äîeither source code or artifacts produced by another system.</p>
<p>For example, when packaging Docker Compose, the input is images; for Helm, the input includes images, startup config, and Helm templates, and the output is YAML.</p>
<h3 id="artifacts">Artifacts</h3>
<p>An artifact is a collection of data that can run in a given environment. It is made of executables and startup config, usually as files, and runs in a runtime. Artifacts can nest other artifacts.</p>
<p>The most common form is a binary (ELF); it can also be something that runs in a specific environment, such as a container image. Artifacts are typically transferred as files.</p>
<h3 id="installer">Installer</h3>
<p>An installer is a tool that puts an artifact into a runtime. It deploys the artifact and ensures it runs. Examples: dpkg, Pacman, or self-extracting installers on Windows. For Kubernetes, we use <code>kubectl</code>; Helm uses the <code>helm</code> command.</p>
<h2 id="linux-community-practice">Linux Community Practice</h2>
<p>Once we understand these concepts, we may notice how close they are to what the Linux community has been doing for years. Setting aside cloud-native buzzwords, the Linux world already had a full solution.</p>
<p>Each layer of artifacts introduces new config / extension / values / env vars‚Äîwe call all of this <strong>configuration</strong>. This packaging info brings its own challenges at scale.</p>
<blockquote>
<p>Proudly using Arch Linux.</p></blockquote>
<h3 id="arch-linux-practice">Arch Linux Practice</h3>
<p>Arch Linux uses <a href="https://wiki.archlinux.org/title/Pacman">Pacman</a> as the package installer and has a full <a href="https://wiki.archlinux.org/title/Arch_build_system">build system</a>. The <a href="https://wiki.archlinux.org/title/PKGBUILD">PKGBUILD</a> describes how a package is built; it is a Bash subset and the core file for the package.</p>
<p>For versioning, Arch has a clear scheme and a full <mark>artifact nesting</mark> story. In <code>PKGBUILD</code>, <code>pkgver</code> is the upstream version (with normalisation such as <code>_</code> for <code>-</code> and timestamp format). <code>pkgrel</code> is the release number (not build number); it is incremented on each release to track Arch releases. When most of the <code>PKGBUILD</code> changes, the release number changes. <code>epoch</code> is a last-resort mechanism to force a newer version by breaking version comparison; it defaults to 0 and is hidden.</p>
<p><code>PKGBUILD</code> also uses versioned dependencies to handle modules. For example, the <code>base-devel</code> package depends on 26 base packages, and <a href="https://gitlab.archlinux.org/archlinux/packaging/packages/base-devel/-/blob/main/PKGBUILD">that package itself</a> has <mark>no content</mark>. This avoids introducing a separate model (e.g. Group / Product).</p>
<h2 id="gitops-based-version-management">GitOps-Based Version Management</h2>
<p>Back to GitOps version management: with the analysis above, can we answer the original questions?</p>
<ul>
<li>How are customer-facing artifacts composed, how do we define their version, and how do we present all versions?
<ul>
<li>Use a <code>VERSION</code> file for the software (upstream) version.</li>
<li>Each artifact form has its own version, tied to upstream‚Äîe.g. <code>v1.2.3-afe12c</code> for the Git repo, <code>v1.2.3-afe12c-b1</code> for the image build.</li>
</ul>
</li>
<li>How do we resolve version dependencies within a set of software?
<ul>
<li>Leave this to the installer; the metadata is usually in the packaging info and consumed by the installer.</li>
</ul>
</li>
<li>How do we represent a system formed by a set of software?
<ul>
<li>Create a new artifact with no upstream version; its content may be empty but it carries packaging and dependency info.</li>
<li>Alternatively, introduce a dedicated concept; that depends on how the packer and installer work together.</li>
</ul>
</li>
</ul>
<h2 id="summary">Summary</h2>
<p>The wisdom of version management is already present in RPM / DEB / PKGBUILD. We give the application author the right to define version, we allow artifact nesting, and we let versioning span multiple layers.</p>
<p>We want the version of the running artifact to still be derived from the original application (Upstream) version. In large-scale cluster management, it matters that every running program knows where it came from and what it is.</p>
]]></content:encoded>
    </item>
    <item>
      <title>Architecture Design the Easy Way</title>
      <link>https://en.blog.alswl.com/2023/07/architecture-design-the-easy-way/</link>
      <pubDate>Sat, 29 Jul 2023 14:54:27 +0800</pubDate>
      <guid>https://en.blog.alswl.com/2023/07/architecture-design-the-easy-way/</guid>
      <description>&lt;p&gt;




&lt;img loading=&#34;lazy&#34; src=&#34;https://en.blog.alswl.com/images/202307/arch-easy.png&#34; alt=&#34;arch-easy&#34;  /&gt;


&lt;/p&gt;
&lt;p&gt;&lt;small&gt;image via &lt;a href=&#34;https://pixabay.com/photos/child-tower-building-blocks-blocks-1864718/&#34;&gt;Pixabay&lt;/a&gt;&lt;/small&gt;&lt;/p&gt;
&lt;h2 id=&#34;overview&#34;&gt;Overview&lt;/h2&gt;
&lt;p&gt;A few days ago, I gave an internal tech talk to my team on best practices for architecture design. I condensed these practices into a &lt;mark&gt;20-character mantra&lt;/mark&gt;:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Architecture looks at the problem&lt;/li&gt;
&lt;li&gt;Requirements look at use cases&lt;/li&gt;
&lt;li&gt;Design looks at the model&lt;/li&gt;
&lt;li&gt;Details look at the sequence&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;I shared this mantra on &lt;a href=&#34;https://twitter.com/alswl/status/1683778487726006272&#34;&gt;Twitter&lt;/a&gt;, and many friends showed strong interest and wanted to go deeper. So I expanded the ideas from that talk into this article.&lt;/p&gt;</description>
      <content:encoded><![CDATA[<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/arch-easy.png" alt="arch-easy"  />


</p>
<p><small>image via <a href="https://pixabay.com/photos/child-tower-building-blocks-blocks-1864718/">Pixabay</a></small></p>
<h2 id="overview">Overview</h2>
<p>A few days ago, I gave an internal tech talk to my team on best practices for architecture design. I condensed these practices into a <mark>20-character mantra</mark>:</p>
<ol>
<li>Architecture looks at the problem</li>
<li>Requirements look at use cases</li>
<li>Design looks at the model</li>
<li>Details look at the sequence</li>
</ol>
<p>I shared this mantra on <a href="https://twitter.com/alswl/status/1683778487726006272">Twitter</a>, and many friends showed strong interest and wanted to go deeper. So I expanded the ideas from that talk into this article.</p>
<h2 id="architecture-design-and-system-analysis">Architecture Design and System Analysis</h2>
<p>Let‚Äôs first clarify <mark>what architecture design and system analysis are</mark> (the latter often shortened to ‚Äúsystem analysis‚Äù). Some of you are familiar with the first but not the second. No worries‚Äîhere‚Äôs how Wikipedia introduces them:</p>
<blockquote>
<p><strong>Architecture</strong>: <strong>Software architecture</strong> is an abstract description of the overall structure and components of software, used to guide the design of various aspects of large software systems.</p>
<p><strong>System analysis</strong> aims to study the interactions between parts (subsystems) in a given system structure, the system‚Äôs external interfaces and boundaries, and the behavior, functions, and limitations of the system as a whole, so as to provide reference and basis for future changes and related decisions.</p></blockquote>
<p>The English definitions may make it clearer:</p>
<ul>
<li>Architecture = Software Architecture (design) = <a href="https://en.wikipedia.org/wiki/Software_architecture">Software architecture - Wikipedia</a></li>
<li>System analysis = <a href="https://en.wikipedia.org/wiki/Systems_analysis">Systems analysis - Wikipedia</a> + <a href="https://en.wikipedia.org/wiki/Systems_design">Systems design - Wikipedia</a></li>
</ul>
<p>What we sometimes call ‚Äúdesign docs‚Äù may cover the whole design process: architecture design, system analysis, and other design activities (communication, PoC, etc.).</p>
<p>Software Architecture (design) = Software Architecture</p>
<ul>
<li>Define and implement the basic structure and organization of software systems</li>
<li>At the business level: clarify the problem, define concepts, present value</li>
<li>At the technical level: choose foundational frameworks, turn uncertainty into certainty</li>
<li>At the engineering level: identify boundaries, split modules, improve development efficiency</li>
</ul>
<p>System Analysis = System Analysis</p>
<ul>
<li>The process of analyzing and studying business needs and problems</li>
<li>At the business level: requirement gathering, requirement analysis</li>
<li>At the technical level: modeling, flowcharts, data flow diagrams, interface design</li>
<li>At the engineering level: implementing requirements within applications and system frameworks</li>
</ul>
<p>Finally, how I see the boundary between the two: I believe <mark>there is no sharp line between architecture design and system analysis</mark>. Any system or module will go through system analysis. You start thinking in terms of architecture when:</p>
<ul>
<li>More than three teams are collaborating, because that involves interests and boundaries.</li>
<li>You begin to introduce uncertainty, whether actively or passively.</li>
<li>You are making trade-offs: what to do first, what to do next.</li>
<li>The system is so complex that it‚Äôs hard to reach consensus and explanation cost rises.</li>
<li>You can provide information others don‚Äôt have.</li>
</ul>
<h2 id="what-is-architecture">What Is Architecture</h2>
<p>Here we focus on <strong>technical</strong> architecture, not business or product architecture. The emphasis is <mark>how to use technical capabilities and methods more efficiently to solve a certain type of problem</mark>.</p>
<p>Technical architecture can be split in two: one is <mark>top-down</mark>‚Äîbusiness, strategy, and framework division; the other is <mark>focused on engineering and implementation (coding)</mark>.</p>
<p>Experienced people often have a more macro view. Common terms include: global, macro, domain, strategy, balance, planning. I turned these into a word cloud:</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/word-cloud-arch-biz.png" alt="word-cloud-arch-biz"  />


</p>
<p><small>generated by <a href="https://tendcode.com/tool/word-cloud/">https://tendcode.com/tool/word-cloud/</a></small></p>
<p>These concepts matter a lot in architecture design and system analysis, because they help us think about the whole picture and even beyond technology‚Äîfrom business value, commercial strategy, and business strategy.</p>
<p>The other kind of architecture is more about engineering design and implementation. Typical keywords: domain modeling, UML, GoF 23, SOLID, high cohesion and low coupling, etc. Word cloud:</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/word-cloud-arch-impl.png" alt="word-cloud-arch-impl"  />


</p>
<p><small>generated by <a href="https://tendcode.com/tool/word-cloud/">https://tendcode.com/tool/word-cloud/</a></small></p>
<p>Architecture is a broad topic. This article picks one angle: <mark>making architectural thinking useful in day-to-day work through practice and methodology, to cover about 80% of engineering design and development scenarios</mark>. I call this ‚Äúarchitecture design the easy way.‚Äù</p>
<h2 id="minimalist-architecture-design--architecture-looks-at-the-problem">Minimalist Architecture Design ‚Äî Architecture Looks at the Problem</h2>
<p>The first and most important step in understanding architecture is to focus on the <strong>problem</strong>: <mark>what problem are you facing, and how will you solve it?</mark></p>
<p>Usually, if our business and systems run stably and we don‚Äôt run into problems, we don‚Äôt need much architecture design. But whenever we do architecture design, it‚Äôs because we have a problem. The problem may come from new requirements, changes in the environment, or the system‚Äôs own evolution. Whatever the source, we have a problem.</p>
<p>After we have a problem, how do we solve it? Like ‚Äúputting the elephant in the fridge,‚Äù we break it into steps.</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/elephant.png" alt="Putting the elephant in the fridge"  />


</p>
<p><small>image via unknown</small></p>
<p>So solving a problem has three steps: first describe the problem clearly, second negotiate and decide until there is agreement, third take action to solve it.</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/q-n-a.png" alt="Problem ‚Äî Agreement ‚Äî Action"  />


</p>
<p>One more question that might sound silly: why can‚Äôt we just solve the problem directly?</p>
<p>Because problems are complex; there are many solution paths, and different options have different pros, cons, and costs. In architecture design we need to make these decisions.</p>
<p>Then why not just make the decision, or even start coding right away?</p>
<p>First, there may be authority issues‚Äîthe architect may not have final say; someone with decision rights may need to sign off. Second, the architect may not be an expert in every area; designing a complex system often requires coordinating multiple parts and domain experts to evaluate and decide together.</p>
<h3 id="example">Example</h3>
<p>Take Prometheus‚Äôs architecture as an example.</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/prometheus-architecture.png" alt="Prometheus architecture"  />


</p>
<p><small>image via <a href="https://prometheus.io/docs/introduction/overview/">Prometheus</a></small></p>
<p>This diagram answers many questions. A few examples:</p>
<ul>
<li>Problem: Push or pull for data collection? What storage? How to design the alerting pipeline?</li>
<li>Decisions: Pull (Pushgateway in a few cases); custom TSDB; Alertmanager to integrate with external systems</li>
<li>ROI: Pull reduces observability cost on targets, no need for a push-based registry; no suitable external implementation at the time; Router/Sub alert mechanism for flexible integration</li>
</ul>
<h3 id="summary">Summary</h3>
<p>Problems drive architecture change; the architecture addresses the problem; architecture review aligns on the solution.</p>
<p>On who gets to decide: I strongly believe architects should form their own view based on domain knowledge, industry judgment, and understanding of the current situation. That thinking should be supported by cause and effect. <mark>A good architect must have a point of view.</mark></p>
<p>One small add: why didn‚Äôt I mention architecture layers or module layers?</p>
<p>Not because layering and frameworks don‚Äôt matter‚Äîeveryone is already professional there. Layering and modularity are basic common sense and skills, so they usually aren‚Äôt the focus of debate and decisions. If you can‚Äôt quickly agree on layers and frameworks, either the team composition is off or the problem is so complex it‚Äôs no longer in the 80% case.</p>
<p>Deliverables at this stage: architecture diagram and shared understanding of problem, value, cost, risk, and responsibilities.</p>
<h2 id="minimalist-architecture-design--requirements-look-at-use-cases">Minimalist Architecture Design ‚Äî Requirements Look at Use Cases</h2>
<p>Requirements are the answer to the problem. I like to <mark>use mind maps or a blank sheet to draw</mark> and make requirements clear. What to draw? Clarify roles and list actions and behaviors.</p>
<p>What‚Äôs a good way to organize everything? I often use a <mark>subject‚Äìverb‚Äìobject (and adjuncts)</mark> approach: who does what, in what scenario (optional), in what state (optional).</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/gramma.jpg" alt="Subject-verb-object"  />


</p>
<p><small>image via unknown</small></p>
<p>Use cases break requirements down clearly, and you keep communicating with the stakeholders in the process.</p>
<p><mark>Demo scripts are the product manager‚Äôs weapon; requirement use cases are the engineer‚Äôs weapon.</mark></p>
<p>Some junior engineers unconsciously become mere executors of requirements. I‚Äôd say engineers who don‚Äôt understand the business aren‚Äôt much different from outsourced labor. The requirement analysis phase is crucial‚Äîit‚Äôs the chance to understand, structure, and redesign the business input. By organizing use cases, we can push back on unrealistic or unreliable requirements.</p>
<p>This is one of the few phases where we can influence (and give feedback to) the requirement side; make the most of it.</p>
<h3 id="example-1">Example</h3>
<p>Here‚Äôs an example of a product use case:</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/netease-music.png" alt="Netease Cloud Music"  />


</p>
<p><small>image via <a href="https://www.woshipm.com/evaluating/3493594.html">Netease Cloud Music product analysis</a></small></p>
<p>This use case was actually summarized by ‚Äúthe other side‚Äù üòÑ, but it still shows how important use cases are.</p>
<h3 id="summary-1">Summary</h3>
<p>Besides subject‚Äìverb‚Äìobject, other useful techniques:</p>
<ul>
<li>User journey (action path): imagine the path the user (or actor) takes to reach their goal</li>
<li>Prioritize solving the 20% of issues on the core path</li>
<li>Organize use cases by role, orthogonal split, etc.; assign use cases to modules</li>
</ul>
<p>Deliverables: demo script, use case diagram.</p>
<h2 id="minimalist-architecture-design--design-looks-at-the-model">Minimalist Architecture Design ‚Äî Design Looks at the Model</h2>
<p>To me, the core of design is the <strong>model</strong>: <mark>the model defines the carrier and boundaries of data</mark>. <mark>Data defines the components; boundaries define ownership and responsibility.</mark> In UML, many entities and objects are used to define model boundaries. As the business system grows in complexity, modeling faces greater challenges.</p>
<p>A few modeling principles I use:</p>
<ul>
<li>Define terms (in both languages if needed), meaning, and notes.</li>
<li>Identify core models (focus on the critical 20%).</li>
<li>Refine and abstract models.</li>
<li>Make relationships between models explicit.</li>
<li>Combine static and dynamic: a few models have behavior; focus on the functions they provide.</li>
<li>Map business model ‚Üî data model.</li>
</ul>
<p>Many people don‚Äôt care about a glossary, but I do. There‚Äôs an effect called ‚Äúforeign language effect‚Äù‚Äîlike using Latin/Greek in natural history to describe species. For non-native English engineers, using English for terms can help focus the discussion.</p>
<p>Always keep the 80/20 rule in mind, especially in design: focus on core objects and zoom in on them rather than getting lost in details. Usually, focusing on the core 20% of models is enough for most scenarios.</p>
<p>When refining and abstracting models, iterate carefully. You can connect this to earlier use case definition and later sequence design; it takes solid domain knowledge. I like to refer to external code and designs at this stage.</p>
<p>Relationships between models are mainly 1:1, 1:N, M:N. Use arrows to show primary vs. secondary clearly. Primary/secondary implies ownership and affects many downstream details (URLs, database, lifecycle, etc.). I recommend avoiding M:N when possible; it often indicates an intermediate credential or relationship/binding.</p>
<p>Besides static data, consider model behavior (only a few models have it). This stage can feed into the next step‚Äîdetailed design.</p>
<p>After the business model, think about the data model. For typical business systems, this mapping is straightforward. Business systems are often stateless and rely on the database for storage. For data-intensive applications (DIA), you need to think about runtime data, lifecycle, and availability (if you have that need, you probably aren‚Äôt reading this far üòÑ).</p>
<h3 id="example-2">Example</h3>
<p>Kubernetes RBAC (Role-Based Access Control) is a common AuthZ (authorization) system (not AuthN‚Äîauthentication).</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/rbac.png" alt="Kubernetes RBAC"  />


</p>
<p><small>image via <a href="https://dev.to/alcide/kubernetes-rbac-moving-from-it-s-complicated-to-in-a-relationship-1bbm">Kubernetes RBAC - DEV Community</a></small></p>
<p>A few questions to consider:</p>
<ul>
<li>Why both Role and ClusterRole? What‚Äôs their structure?</li>
<li>Why not ACL? What‚Äôs the difference between ACL and RBAC?</li>
<li>Why not Policy?</li>
</ul>
<p>Modeling is what gives you these answers.</p>
<h3 id="models-in-non-business-systems">Models in Non-Business Systems</h3>
<p>We‚Äôve been focusing on business models‚Äîwhat users perceive and the product understands, usually stored in the DB.</p>
<p>In infrastructure, there are models too, sometimes called ‚Äúconcepts.‚Äù Infrastructure models are often simpler; business models can be very complex because the world is complex, while infrastructure focuses on narrow, vertical problems.</p>
<p>Infrastructure also leads to more abstract modeling‚Äîe.g. the often-overlooked Manager/Service pattern. Models with data and state, like Executor, are common; Registry and Queue are common too.</p>
<p>Kubernetes <a href="https://kubernetes.io/docs/concepts/">Concepts</a>‚Äîdozens of subcategories and hundreds of concepts‚Äîshow how complex such a system can be.</p>
<h3 id="summary-2">Summary</h3>
<p>Models are not just data; they define boundaries, and boundaries determine ownership and responsibility.</p>
<p>Design models in both static and dynamic terms: statically what they hold, dynamically what they do.</p>
<p>In infrastructure, deliverables may include UML model diagram, ER diagram, DB DML, class files, OpenAPI/Swagger (partially), etc.</p>
<h2 id="minimalist-architecture-design--details-look-at-the-sequence">Minimalist Architecture Design ‚Äî Details Look at the Sequence</h2>
<blockquote>
<p>Programming = Data structures + Algorithms + Control flow</p></blockquote>
<p>Before turning design into code, the last important step is nailing the details. For stakeholders and decision makers this step may not matter much, but for the implementers (the dev team) it directly affects delivery quality and timeline.</p>
<p>I think details should be captured in <strong>sequence diagrams</strong>.</p>
<p>We often use two kinds of diagrams for details: <mark>flowcharts and sequence diagrams</mark>. They have a lot in common, but I prefer sequence diagrams because they show order and make the boundaries and interactions between systems clear.</p>
<p>My rule of thumb: one sequence diagram per use case.</p>
<h3 id="example-3">Example</h3>
<p>Example from an official AWS blog:</p>
<p>




<img loading="lazy" src="https://en.blog.alswl.com/img/202307/aws-seq.png" alt="Header-based API Gateway versioning with CloudFront"  />


</p>
<p><small>via <a href="https://aws.amazon.com/blogs/architecture/sequence-diagrams-enrich-your-understanding-of-distributed-architectures/">AWS Architecture Blog</a></small></p>
<p>The diagram shows a sequence for using CloudFront in AWS: how requests flow across systems and how various error cases are handled.</p>
<h3 id="summary-3">Summary</h3>
<p>A few tips for sequence diagrams:</p>
<ul>
<li>User action is the trigger</li>
<li>System boundaries must be clear</li>
<li>Request and response = synchronous</li>
<li>Request without response = asynchronous</li>
</ul>
<p>Usually, once the sequence diagram is solid, you can hand off to the team with confidence. Without it, you rely entirely on collaboration and trust.</p>
<p>Deliverables: sequence diagram, API docs (OpenAPI/Swagger), frontend service generation (if applicable).</p>
<h2 id="minimalist-architecture-design--wrap-up">Minimalist Architecture Design ‚Äî Wrap-up</h2>
<p>By this point we haven‚Äôt written code yet, but we know what to do and what it will look like. We have class structure, API definitions, frontend service generation, etc. Multiple teams can work in parallel without obvious bottlenecks.</p>
<ul>
<li>‚úÖ Problem defined</li>
<li>‚úÖ Approach chosen</li>
<li>‚úÖ Class structure, API definitions</li>
<li>‚úÖ Server-side code generation</li>
<li>‚úÖ Flow agreed</li>
<li>‚úÖ About 1/3 of reporting material</li>
<li>‚úÖ About 1/2 of tech talk material</li>
</ul>
<p>If you need to report later, you already have about one third of the content. If you need to write a tech talk, you have about half.</p>
<p>If the project is a simple CRUD app, there usually aren‚Äôt many hard parts.</p>
<p>If it‚Äôs a data-intensive application (DIA), you need to design and implement storage and think about consistency and concurrency. For a complex system, you also need to check for uncertainty at the boundaries between systems. If you have sync challenges (e.g. framework changes, communication layer changes), de-risk early. (I don‚Äôt think doing tech upgrades and feature development in parallel is wise.)</p>
<h2 id="extra--drawing-tools">Extra ‚Äî Drawing Tools</h2>
<p>I have my own set of drawing tools for architecture diagrams, flowcharts, etc. P.S. I even design logos for my products‚Äîmaybe I‚Äôve always wanted to be a designer üôÇ</p>
<p>As an engineer, you should build your own drawing UI kit, get good at it, and put together a toolbox so you can turn ideas in your head into documents quickly.</p>
<p>My toolkit is fairly rich. For architecture diagrams:</p>
<ul>
<li>Block diagrams
<ul>
<li>OmniGraffle (paid, complex, polished)</li>
<li>Excalidraw (simple, casual)</li>
</ul>
</li>
<li>Deployment diagrams
<ul>
<li>Excalidraw</li>
</ul>
</li>
<li>Mind maps
<ul>
<li>SimpleMind (paid)</li>
<li>XMind (paid)</li>
</ul>
</li>
</ul>
<p>For engineering design (UML):</p>
<ul>
<li>Use cases
<ul>
<li>Yuque drawing</li>
<li>PlantUML (Yuque can render it)</li>
</ul>
</li>
<li>Sequence diagrams
<ul>
<li>PlantUML</li>
</ul>
</li>
<li>State diagrams
<ul>
<li>Yuque</li>
</ul>
</li>
<li>ER diagrams
<ul>
<li>Excalidraw</li>
</ul>
</li>
<li>Gantt charts
<ul>
<li>PlantUML</li>
</ul>
</li>
</ul>
<p>Shameless plug: I maintain <a href="https://excalidraw.alswl.com/">Excalidraw (Fork)</a>, with Chinese handwriting fonts and consistent style.</p>
<h2 id="extra--the-hard-way">Extra ‚Äî the Hard Way</h2>
<p>We started from a simple, practical architecture design flow. If you‚Äôre the curious type, that may not be enough‚Äîthere‚Äôs still the 20% of complex cases. Here are some keywords and book recommendations to go deeper:</p>
<ul>
<li>Principles</li>
<li>Philosophy</li>
<li>Ideas</li>
<li>Laws</li>
<li>Methodology</li>
<li>Case studies</li>
</ul>
<p>Some books that help:</p>
<ul>
<li>Business architecture
<ul>
<li><a href="https://book.douban.com/subject/1792387/">Applying UML and Patterns - Craig Larman</a></li>
<li><a href="https://book.douban.com/subject/5344973/">Domain-Driven Design - Eric Evans</a></li>
</ul>
</li>
<li>Technical architecture
<ul>
<li><a href="https://book.douban.com/subject/30468597/">Refactoring - Martin Fowler</a></li>
<li><a href="https://book.douban.com/subject/4199741/">Clean Code - Robert C. Martin</a></li>
</ul>
</li>
</ul>
]]></content:encoded>
    </item>
  </channel>
</rss>
