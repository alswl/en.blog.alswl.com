---
title: "Architecture Design the Easy Way"
slug: "architecture-design-the-easy-way"
date: 2023-07-29T14:54:27+08:00
categories: ["coding"]
tags: ["Design", "Architecture"]
typora-copy-images-to: ../../static/images/202307
---

![arch-easy](../../static/images/202307/arch-easy.png)

<small>image via [Pixabay](https://pixabay.com/photos/child-tower-building-blocks-blocks-1864718/)</small>

## Overview

A few days ago, I gave an internal tech talk to my team on best practices for architecture design. I condensed these practices into a <mark>20-character mantra</mark>:

1. Architecture looks at the problem
2. Requirements look at use cases
3. Design looks at the model
4. Details look at the sequence

I shared this mantra on [Twitter](https://twitter.com/alswl/status/1683778487726006272), and many friends showed strong interest and wanted to go deeper. So I expanded the ideas from that talk into this article.

## Architecture Design and System Analysis

Let‚Äôs first clarify <mark>what architecture design and system analysis are</mark> (the latter often shortened to ‚Äúsystem analysis‚Äù). Some of you are familiar with the first but not the second. No worries‚Äîhere‚Äôs how Wikipedia introduces them:

> **Architecture**: **Software architecture** is an abstract description of the overall structure and components of software, used to guide the design of various aspects of large software systems.
>
> **System analysis** aims to study the interactions between parts (subsystems) in a given system structure, the system‚Äôs external interfaces and boundaries, and the behavior, functions, and limitations of the system as a whole, so as to provide reference and basis for future changes and related decisions.

The English definitions may make it clearer:

- Architecture = Software Architecture (design) = [Software architecture - Wikipedia](https://en.wikipedia.org/wiki/Software_architecture)
- System analysis = [Systems analysis - Wikipedia](https://en.wikipedia.org/wiki/Systems_analysis) + [Systems design - Wikipedia](https://en.wikipedia.org/wiki/Systems_design)

What we sometimes call ‚Äúdesign docs‚Äù may cover the whole design process: architecture design, system analysis, and other design activities (communication, PoC, etc.).

Software Architecture (design) = Software Architecture

- Define and implement the basic structure and organization of software systems
- At the business level: clarify the problem, define concepts, present value
- At the technical level: choose foundational frameworks, turn uncertainty into certainty
- At the engineering level: identify boundaries, split modules, improve development efficiency

System Analysis = System Analysis

- The process of analyzing and studying business needs and problems
- At the business level: requirement gathering, requirement analysis
- At the technical level: modeling, flowcharts, data flow diagrams, interface design
- At the engineering level: implementing requirements within applications and system frameworks

Finally, how I see the boundary between the two: I believe <mark>there is no sharp line between architecture design and system analysis</mark>. Any system or module will go through system analysis. You start thinking in terms of architecture when:

- More than three teams are collaborating, because that involves interests and boundaries.
- You begin to introduce uncertainty, whether actively or passively.
- You are making trade-offs: what to do first, what to do next.
- The system is so complex that it‚Äôs hard to reach consensus and explanation cost rises.
- You can provide information others don‚Äôt have.

## What Is Architecture

Here we focus on **technical** architecture, not business or product architecture. The emphasis is <mark>how to use technical capabilities and methods more efficiently to solve a certain type of problem</mark>.

Technical architecture can be split in two: one is <mark>top-down</mark>‚Äîbusiness, strategy, and framework division; the other is <mark>focused on engineering and implementation (coding)</mark>.

Experienced people often have a more macro view. Common terms include: global, macro, domain, strategy, balance, planning. I turned these into a word cloud:

![word-cloud-arch-biz](../../static/images/202307/word-cloud-arch-biz.png)

<small>generated by https://tendcode.com/tool/word-cloud/</small>

These concepts matter a lot in architecture design and system analysis, because they help us think about the whole picture and even beyond technology‚Äîfrom business value, commercial strategy, and business strategy.

The other kind of architecture is more about engineering design and implementation. Typical keywords: domain modeling, UML, GoF 23, SOLID, high cohesion and low coupling, etc. Word cloud:

![word-cloud-arch-impl](../../static/images/202307/word-cloud-arch-impl.png)

<small>generated by https://tendcode.com/tool/word-cloud/</small>

Architecture is a broad topic. This article picks one angle: <mark>making architectural thinking useful in day-to-day work through practice and methodology, to cover about 80% of engineering design and development scenarios</mark>. I call this ‚Äúarchitecture design the easy way.‚Äù

## Minimalist Architecture Design ‚Äî Architecture Looks at the Problem

The first and most important step in understanding architecture is to focus on the **problem**: <mark>what problem are you facing, and how will you solve it?</mark>

Usually, if our business and systems run stably and we don‚Äôt run into problems, we don‚Äôt need much architecture design. But whenever we do architecture design, it‚Äôs because we have a problem. The problem may come from new requirements, changes in the environment, or the system‚Äôs own evolution. Whatever the source, we have a problem.

After we have a problem, how do we solve it? Like ‚Äúputting the elephant in the fridge,‚Äù we break it into steps.

![Putting the elephant in the fridge](../../static/images/202307/elephant.png)

<small>image via unknown</small>

So solving a problem has three steps: first describe the problem clearly, second negotiate and decide until there is agreement, third take action to solve it.

![Problem ‚Äî Agreement ‚Äî Action](../../static/images/202307/q-n-a.png)

One more question that might sound silly: why can‚Äôt we just solve the problem directly?

Because problems are complex; there are many solution paths, and different options have different pros, cons, and costs. In architecture design we need to make these decisions.

Then why not just make the decision, or even start coding right away?

First, there may be authority issues‚Äîthe architect may not have final say; someone with decision rights may need to sign off. Second, the architect may not be an expert in every area; designing a complex system often requires coordinating multiple parts and domain experts to evaluate and decide together.

### Example

Take Prometheus‚Äôs architecture as an example.

![Prometheus architecture](../../static/images/202307/prometheus-architecture.png)

<small>image via [Prometheus](https://prometheus.io/docs/introduction/overview/)</small>

This diagram answers many questions. A few examples:

- Problem: Push or pull for data collection? What storage? How to design the alerting pipeline?
- Decisions: Pull (Pushgateway in a few cases); custom TSDB; Alertmanager to integrate with external systems
- ROI: Pull reduces observability cost on targets, no need for a push-based registry; no suitable external implementation at the time; Router/Sub alert mechanism for flexible integration

### Summary

Problems drive architecture change; the architecture addresses the problem; architecture review aligns on the solution.

On who gets to decide: I strongly believe architects should form their own view based on domain knowledge, industry judgment, and understanding of the current situation. That thinking should be supported by cause and effect. <mark>A good architect must have a point of view.</mark>

One small add: why didn‚Äôt I mention architecture layers or module layers?

Not because layering and frameworks don‚Äôt matter‚Äîeveryone is already professional there. Layering and modularity are basic common sense and skills, so they usually aren‚Äôt the focus of debate and decisions. If you can‚Äôt quickly agree on layers and frameworks, either the team composition is off or the problem is so complex it‚Äôs no longer in the 80% case.

Deliverables at this stage: architecture diagram and shared understanding of problem, value, cost, risk, and responsibilities.

## Minimalist Architecture Design ‚Äî Requirements Look at Use Cases

Requirements are the answer to the problem. I like to <mark>use mind maps or a blank sheet to draw</mark> and make requirements clear. What to draw? Clarify roles and list actions and behaviors.

What‚Äôs a good way to organize everything? I often use a <mark>subject‚Äìverb‚Äìobject (and adjuncts)</mark> approach: who does what, in what scenario (optional), in what state (optional).

![Subject-verb-object](../../static/images/202307/gramma.jpg)

<small>image via unknown</small>

Use cases break requirements down clearly, and you keep communicating with the stakeholders in the process.

<mark>Demo scripts are the product manager‚Äôs weapon; requirement use cases are the engineer‚Äôs weapon.</mark>

Some junior engineers unconsciously become mere executors of requirements. I‚Äôd say engineers who don‚Äôt understand the business aren‚Äôt much different from outsourced labor. The requirement analysis phase is crucial‚Äîit‚Äôs the chance to understand, structure, and redesign the business input. By organizing use cases, we can push back on unrealistic or unreliable requirements.

This is one of the few phases where we can influence (and give feedback to) the requirement side; make the most of it.

### Example

Here‚Äôs an example of a product use case:

![Netease Cloud Music](../../static/images/202307/netease-music.png)

<small>image via [Netease Cloud Music product analysis](https://www.woshipm.com/evaluating/3493594.html)</small>

This use case was actually summarized by ‚Äúthe other side‚Äù üòÑ, but it still shows how important use cases are.

### Summary

Besides subject‚Äìverb‚Äìobject, other useful techniques:

- User journey (action path): imagine the path the user (or actor) takes to reach their goal
- Prioritize solving the 20% of issues on the core path
- Organize use cases by role, orthogonal split, etc.; assign use cases to modules

Deliverables: demo script, use case diagram.

## Minimalist Architecture Design ‚Äî Design Looks at the Model

To me, the core of design is the **model**: <mark>the model defines the carrier and boundaries of data</mark>. <mark>Data defines the components; boundaries define ownership and responsibility.</mark> In UML, many entities and objects are used to define model boundaries. As the business system grows in complexity, modeling faces greater challenges.

A few modeling principles I use:

- Define terms (in both languages if needed), meaning, and notes.
- Identify core models (focus on the critical 20%).
- Refine and abstract models.
- Make relationships between models explicit.
- Combine static and dynamic: a few models have behavior; focus on the functions they provide.
- Map business model ‚Üî data model.

Many people don‚Äôt care about a glossary, but I do. There‚Äôs an effect called ‚Äúforeign language effect‚Äù‚Äîlike using Latin/Greek in natural history to describe species. For non-native English engineers, using English for terms can help focus the discussion.

Always keep the 80/20 rule in mind, especially in design: focus on core objects and zoom in on them rather than getting lost in details. Usually, focusing on the core 20% of models is enough for most scenarios.

When refining and abstracting models, iterate carefully. You can connect this to earlier use case definition and later sequence design; it takes solid domain knowledge. I like to refer to external code and designs at this stage.

Relationships between models are mainly 1:1, 1:N, M:N. Use arrows to show primary vs. secondary clearly. Primary/secondary implies ownership and affects many downstream details (URLs, database, lifecycle, etc.). I recommend avoiding M:N when possible; it often indicates an intermediate credential or relationship/binding.

Besides static data, consider model behavior (only a few models have it). This stage can feed into the next step‚Äîdetailed design.

After the business model, think about the data model. For typical business systems, this mapping is straightforward. Business systems are often stateless and rely on the database for storage. For data-intensive applications (DIA), you need to think about runtime data, lifecycle, and availability (if you have that need, you probably aren‚Äôt reading this far üòÑ).

### Example

Kubernetes RBAC (Role-Based Access Control) is a common AuthZ (authorization) system (not AuthN‚Äîauthentication).

![Kubernetes RBAC](../../static/images/202307/rbac.png)

<small>image via [Kubernetes RBAC - DEV Community](https://dev.to/alcide/kubernetes-rbac-moving-from-it-s-complicated-to-in-a-relationship-1bbm)</small>

A few questions to consider:

- Why both Role and ClusterRole? What‚Äôs their structure?
- Why not ACL? What‚Äôs the difference between ACL and RBAC?
- Why not Policy?

Modeling is what gives you these answers.

### Models in Non-Business Systems

We‚Äôve been focusing on business models‚Äîwhat users perceive and the product understands, usually stored in the DB.

In infrastructure, there are models too, sometimes called ‚Äúconcepts.‚Äù Infrastructure models are often simpler; business models can be very complex because the world is complex, while infrastructure focuses on narrow, vertical problems.

Infrastructure also leads to more abstract modeling‚Äîe.g. the often-overlooked Manager/Service pattern. Models with data and state, like Executor, are common; Registry and Queue are common too.

Kubernetes [Concepts](https://kubernetes.io/docs/concepts/)‚Äîdozens of subcategories and hundreds of concepts‚Äîshow how complex such a system can be.

### Summary

Models are not just data; they define boundaries, and boundaries determine ownership and responsibility.

Design models in both static and dynamic terms: statically what they hold, dynamically what they do.

In infrastructure, deliverables may include UML model diagram, ER diagram, DB DML, class files, OpenAPI/Swagger (partially), etc.

## Minimalist Architecture Design ‚Äî Details Look at the Sequence

> Programming = Data structures + Algorithms + Control flow

Before turning design into code, the last important step is nailing the details. For stakeholders and decision makers this step may not matter much, but for the implementers (the dev team) it directly affects delivery quality and timeline.

I think details should be captured in **sequence diagrams**.

We often use two kinds of diagrams for details: <mark>flowcharts and sequence diagrams</mark>. They have a lot in common, but I prefer sequence diagrams because they show order and make the boundaries and interactions between systems clear.

My rule of thumb: one sequence diagram per use case.

### Example

Example from an official AWS blog:

![Header-based API Gateway versioning with CloudFront](../../static/images/202307/aws-seq.png)

<small>via [AWS Architecture Blog](https://aws.amazon.com/blogs/architecture/sequence-diagrams-enrich-your-understanding-of-distributed-architectures/)</small>

The diagram shows a sequence for using CloudFront in AWS: how requests flow across systems and how various error cases are handled.

### Summary

A few tips for sequence diagrams:

- User action is the trigger
- System boundaries must be clear
- Request and response = synchronous
- Request without response = asynchronous

Usually, once the sequence diagram is solid, you can hand off to the team with confidence. Without it, you rely entirely on collaboration and trust.

Deliverables: sequence diagram, API docs (OpenAPI/Swagger), frontend service generation (if applicable).

## Minimalist Architecture Design ‚Äî Wrap-up

By this point we haven‚Äôt written code yet, but we know what to do and what it will look like. We have class structure, API definitions, frontend service generation, etc. Multiple teams can work in parallel without obvious bottlenecks.

- ‚úÖ Problem defined
- ‚úÖ Approach chosen
- ‚úÖ Class structure, API definitions
- ‚úÖ Server-side code generation
- ‚úÖ Flow agreed
- ‚úÖ About 1/3 of reporting material
- ‚úÖ About 1/2 of tech talk material

If you need to report later, you already have about one third of the content. If you need to write a tech talk, you have about half.

If the project is a simple CRUD app, there usually aren‚Äôt many hard parts.

If it‚Äôs a data-intensive application (DIA), you need to design and implement storage and think about consistency and concurrency. For a complex system, you also need to check for uncertainty at the boundaries between systems. If you have sync challenges (e.g. framework changes, communication layer changes), de-risk early. (I don‚Äôt think doing tech upgrades and feature development in parallel is wise.)

## Extra ‚Äî Drawing Tools

I have my own set of drawing tools for architecture diagrams, flowcharts, etc. P.S. I even design logos for my products‚Äîmaybe I‚Äôve always wanted to be a designer üôÇ

As an engineer, you should build your own drawing UI kit, get good at it, and put together a toolbox so you can turn ideas in your head into documents quickly.

My toolkit is fairly rich. For architecture diagrams:

- Block diagrams
  - OmniGraffle (paid, complex, polished)
  - Excalidraw (simple, casual)
- Deployment diagrams
  - Excalidraw
- Mind maps
  - SimpleMind (paid)
  - XMind (paid)

For engineering design (UML):

- Use cases
  - Yuque drawing
  - PlantUML (Yuque can render it)
- Sequence diagrams
  - PlantUML
- State diagrams
  - Yuque
- ER diagrams
  - Excalidraw
- Gantt charts
  - PlantUML

Shameless plug: I maintain [Excalidraw (Fork)](https://excalidraw.alswl.com/), with Chinese handwriting fonts and consistent style.

## Extra ‚Äî the Hard Way

We started from a simple, practical architecture design flow. If you‚Äôre the curious type, that may not be enough‚Äîthere‚Äôs still the 20% of complex cases. Here are some keywords and book recommendations to go deeper:

- Principles
- Philosophy
- Ideas
- Laws
- Methodology
- Case studies

Some books that help:

- Business architecture
  - [Applying UML and Patterns - Craig Larman](https://book.douban.com/subject/1792387/)
  - [Domain-Driven Design - Eric Evans](https://book.douban.com/subject/5344973/)
- Technical architecture
  - [Refactoring - Martin Fowler](https://book.douban.com/subject/30468597/)
  - [Clean Code - Robert C. Martin](https://book.douban.com/subject/4199741/)
